%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/*	Nan.Numerics.Prime
	A simple prime number library
	Copyright 2016 Julio P. Di Egidio
	<mailto:julio@diegidio.name>
	<http://julio.diegidio.name/Projects/Nan.Numerics.Prime/>
	
	This file is part of Nan.Numerics.Prime.
	
	Nan.Numerics.Prime is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.
	
	Nan.Numerics.Prime is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	
	You should have received a copy of the GNU General Public License
	along with Nan.Numerics.Prime.  If not, see <http://www.gnu.org/licenses/>.
*/
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% (SWI-Prolog 7.3.25)

% TODO: Implement dynamic wheel with option for level?

:- module(prime_whl, []).

:- public
	test_/2,		% +N:posint, -Cert:boolean
	next_p_/3,		% +W:posint, -P:posint, -Cert:boolean
	prev_p_/3,		% +W:posint, -P:posint, -Cert:boolean
	right_/3,		% +N:posint, -P:posint, -Cert:boolean
	left_/3,		% +N:posint, -P:posint, -Cert:boolean
	%%
	wlev_/1,		% -Lev:nonneg
	wnext_/1,		% +Lev:nonneg
	wnext_/0,		% 
	wzero_/0.		% 

/** <module> A simple prime number library :: wheel

Module =prime_whl= provides low-level predicates to test candidate
primality of numbers based on a prime wheel of level =4=, i.e. generated by
the first =4= prime numbers.

*NOTE*: Access to predicates in this module is not synchronized.

*NOTE*: Predicates in this module are not meant for public use.

@author		Julio P. Di Egidio
@version	1.3.0-beta
@copyright	2016 Julio P. Di Egidio
@license	GNU GPLv3
@tbd		Implement dynamic wheel with option for level?
*/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%!	test_(+N:posint, -Cert:boolean) is semidet.
%
%	True if N is a candidate prime number.
%
%	Cert is =true= if N is certainly prime, otherwise it is =false=.

test_(N, Cert) :-
	w__test(N, Cert).

%	next_p_(+P0:posint, -P:posint, -Cert:boolean) is det.

next_p_(P0, P, Cert) :-
	w__next_p(P0, P, Cert).

%	prev_p_(+P0:posint, -P:posint, -Cert:boolean) is semidet.

prev_p_(P0, P, Cert) :-
	w__prev_p(P0, P, Cert).

%!	right_(+N:posint, -P:posint, -Cert:boolean) is det.
%
%	P is the smallest candidate prime number greater than or equal to N.
%
%	Cert is =true= if P is certainly prime, otherwise it is =false=.

right_(N, P, Cert) :-
	w__right(N, P, Cert).

%!	left_(+N:posint, -P:posint, -Cert:boolean) is semidet.
%
%	P is the greatest candidate prime number less than or equal to N.
%	Fails if N equals =1=.
%
%	Cert is =true= if P is certainly prime, otherwise it is =false=.

left_(N, P, Cert) :-
	w__left(N, P, Cert).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%!	wlev_(-Lev:nonneg) is det.
%
%	Lev is the number of consecutive prime numbers starting from =2= that
%	generate this wheel.

wlev_(Lev) :-
	w__lev(Lev).

%	wnext_(+Lev:nonneg) is det.

wnext_(Lev) :-
	w__lev(Lev0),
	Lev0 >= Lev, !.
wnext_(Lev) :-
	w__next,
	wnext_(Lev).

%	wnext_ is det.

wnext_ :-
	w__next.

%	wzero_ is det.

wzero_ :-
	w__zero.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%	w__test(+N:posint, -Cert:boolean) is semidet.

w__test(1, _) :- !, fail.
w__test(N, Cert) :-
	w__p0(P0),
	w__test__do(N, P0, Cert).

w__test__do(N, P0, true) :-
	w__a_is(N, P0), !,
	w__a(N, _, _).
w__test__do(N, P0, Cert) :-
	w__pL(PL),
	w__p_I0(N, P0, PL, I0),
	w__p(I0, _, _),
	w__cert(N, P0, Cert).

%	w__next_p(+W:posint, -P:posint, -Cert:boolean) is det.

w__next_p(W, P, Cert) :-
	w__p0(P0),
	w__next_p__do(W, P0, P, Cert).

w__next_p__do(W, P0, P, true) :-
	w__a_is(W, P0), !,
	w__a(W, _, P).
w__next_p__do(W, P0, P, Cert) :-
	w__pL(PL),
	w__p_I0(W, P0, PL, I0),
	w__p(I0, _, ROff),
	P is W + ROff,
	w__cert(P, P0, Cert).

%	w__prev_p(+W:posint, -P:posint, -Cert:boolean) is semidet.

w__prev_p(2, _, _) :- !, fail.
w__prev_p(W, P, Cert) :-
	w__p0(P0),
	w__prev_p__do(W, P0, P, Cert).

w__prev_p__do(W, P0, P, true) :-
	w__a_is(W, P0), !,
	w__a(W, P, _).
w__prev_p__do(P0, P0, P, true) :- !,
	w__a(P, _, P0).
w__prev_p__do(W, P0, P, Cert) :-
	w__pL(PL),
	w__p_I0(W, P0, PL, I0),
	w__p(I0, LOff, _),
	P is W - LOff,
	w__cert(P, P0, Cert).

%	w__right(+N:posint, -P:posint, -Cert:boolean) is det.

w__right(1, 2, true) :- !.
w__right(2, 2, true) :- !.
w__right(N, P, Cert) :-
	w__p0(P0),
	w__right__n1(N, N1),
	w__right__do(N1, P0, P, Cert).

w__right__n1(N, N1) :-
	N /\ 1 =:= 0, !,
	N1 is N + 1.
w__right__n1(N, N).

w__right__do(N1, P0, P, true) :-
	w__a_is(N1, P0), !,
	w__right__a(N1, P0, P).
w__right__do(N1, P0, P, Cert) :-
	w__pL(PL),
	w__p_I0(N1, P0, PL, I0),
	w__right__p(I0, I0, N1, P0, PL, P),
	w__cert(P, P0, Cert).

w__right__a(N1, _, N1) :-
	w__a(N1, _, _), !.
w__right__a(N1, P0, P) :-
	N2 is N1 + 2,
	N2 < P0, !,
	w__right__a(N2, P0, P).
w__right__a(_, P0, P0).

w__right__p(I1, I0, N1, _, _, P) :-
	w__p(I1, _, _), !,
	P is N1 + (I1 - I0).
w__right__p(I1, I0, N1, P0, PL, P) :-
	I2 is I1 + 2,
	I2 < PL, !,
	w__right__p(I2, I0, N1, P0, PL, P).
w__right__p(_, _, N1, P0, PL, P) :-
	P is PL * ceiling((N1 - P0) / PL) + P0.

%	w__left(+N:posint, -P:posint, -Cert:boolean) is semidet.

w__left(1, _, _) :- !, fail.
w__left(2, 2, true) :- !.
w__left(N, P, Cert) :-
	w__p0(P0),
	w__left__n1(N, N1),
	w__left__do(N1, P0, P, Cert).

w__left__n1(N, N1) :-
	N /\ 1 =:= 0, !,
	N1 is N - 1.
w__left__n1(N, N).

w__left__do(N1, P0, P, true) :-
	w__a_is(N1, P0), !,
	w__left__a(N1, P).
w__left__do(N1, P0, P, Cert) :-
	w__pL(PL),
	w__p_I0(N1, P0, PL, I0),
	w__left__p(I0, I0, N1, P),
	w__cert(P, P0, Cert).

w__left__a(N1, N1) :-
	w__a(N1, _, _), !.
w__left__a(N1, P) :-
	N2 is N1 - 2,
	w__left__a(N2, P).

w__left__p(I1, I0, N1, P) :-
	w__p(I1, _, _), !,
	P is N1 - (I0 - I1).
w__left__p(I1, I0, N1, P) :-
	I2 is I1 - 2,
	w__left__p(I2, I0, N1, P).

%	w__a_is(+N:posint, +P0:posint) is semidet.

w__a_is(N, P0) :-
	N < P0.

%	w__p_I0(+N:posint, +P0:posint, +PL:posint, -I0:nonneg) is det.

w__p_I0(N, P0, PL, I0) :-
	I0 is (N - P0) mod PL.

%	w__cert(+N:posint, +P0:posint, -Cert:boolean) is det.

w__cert(N, P0, true) :-
	N < P0 * P0, !.
w__cert(_, _, false).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%	w__lev(-Lev:nonneg) is det.
%	w__p0(-P0:posint) is det.
%	w__pL(-PL:posint) is det.
%	w__a(-P:posint, -L:posint, -R:posint) is nondet.
%	w__p(-I0:nonneg, -LOff:posint, -ROff:posint) is multi.

:- dynamic
	w__lev/1,
	w__p0/1,
	w__pL/1,
	w__a/3,
	w__p/3.

% prime_whl:w__zero,prime_whl:w__list.
% prime_whl:w__next,prime_whl:w__list.
% between(1,30,N),prime_whl:w__test(N,Cert),writeln([N,Cert]),fail;true.

%	w__stat is det.

w__stat :-
	w__lev(Lev), w__p0(P0), w__pL(PL), format('L(~d, ~d, ~d)~n', [Lev, P0, PL]).

%	w__list is det.

w__list :-
	w__stat,
	forall(w__a(P, L, R), format('A(~d, ~d, ~d)~n', [P, L, R])),
	forall(w__p(I0, LOff, ROff), format('P(~d, ~d, ~d)~n', [I0, LOff, ROff])).

%	w__zero is det.

w__zero :-
	retractall(w__lev(_)),
	retractall(w__p0(_)),
	retractall(w__pL(_)),
	retractall(w__a(_, _, _)),
	retractall(w__p(_, _, _)),
	assertz(w__lev(0)),
	assertz(w__p0(2)),
	assertz(w__pL(1)),
	assertz(w__p(0, 1, 1)).

%	w__next is det.

w__next :-
	retract(w__lev(Lev)),
	retract(w__p0(P0)),
	retract(w__pL(PL)),
	w__next__L0(P0, L0),
	w__next__as(P0, L0),
	w__next__ps(P0, PL, P1, Ps),
	w__next__rs(0, 0, Ps, P0, (P1, PL), (fail, 0)),
	w__next__ls(Lev, P0, P1, PL).

w__next__L0(P0, L0) :-
	w__a(L0, _, P0), !.
w__next__L0(_, 1).

w__next__as(P0, L0) :-
	w__p(0, _, ROff0),
	R0 is P0 + ROff0,
	assertz(w__a(P0, L0, R0)).

w__next__ps(P0, PL, P1, Ps) :-
	retract(w__p(0, LOff0, ROff0)),
	assertz(w__p(PL, LOff0, ROff0)),
	once(w__p(IOff, _, _)),
	P1 is P0 + IOff,
	findall((I1, LOff, ROff),
	(	retract(w__p(I0, LOff, ROff)),
		I1 is I0 - IOff
	), Ps).

w__next__rs(P0, _, _, P0, _, (_, LOffp0)) :- !,
	once(retract(w__p(I0, LOff, ROff))),
	LOff1 is LOff + LOffp0,
	asserta(w__p(I0, LOff1, ROff)).
w__next__rs(N0, A0, Ps, P0, (P1, PL), ILOffp0) :-
	L0 is A0 + P1,
	w__next__qs(Ps, (P0, A0, L0), ILOffp0, ILOffp1),
	N1 is N0 + 1,
	A1 is A0 + PL,
	w__next__rs(N1, A1, Ps, P0, (P1, PL), ILOffp1).

w__next__qs([], _, ILOffp0, ILOffp0).
w__next__qs([(I0, LOff, ROff)| Ps], (P0, A0, L0), (_, LOffp0), ILOffp1) :-
	(I0 + L0) mod P0 =\= 0, !,
	I1 is I0 + A0,
	LOff1 is LOff + LOffp0,
	assertz(w__p(I1, LOff1, ROff)),
	w__next__qs(Ps, (P0, A0, L0), (I1, 0), ILOffp1).
w__next__qs([(I0, LOff, ROff)| Ps], PAL0, (Ip0, LOffp0), ILOffp1) :-
	retract(w__p(Ip0, LOffp, ROffp)),
	ROffp1 is ROffp + ROff,
	assertz(w__p(Ip0, LOffp, ROffp1)),
	LOff1 is LOff + LOffp0,
	w__next__qs(Ps, PAL0, (I0, LOff1), ILOffp1).

w__next__ls(Lev, P0, P1, PL) :-
	Lev1 is Lev + 1,
	PL1 is P0 * PL,
	assertz(w__lev(Lev1)),
	assertz(w__p0(P1)),
	assertz(w__pL(PL1)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
